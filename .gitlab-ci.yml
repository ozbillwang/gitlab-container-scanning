---
variables:
  BUILD_IMAGES: registry.gitlab.com/gitlab-org/security-products/dependencies/build-images
  DOCKERFILE_SOURCE: Dockerfile
  DOCKER_IMAGE: $CI_REGISTRY_IMAGE/tmp/$SCANNER:$CI_COMMIT_SHA
  DEPLOY_REGISTRY_IMAGE: registry.gitlab.com/security-products/container-scanning
  SCANNER: trivy
  DEFAULT_SCANNER: trivy
  GIT_STRATEGY: fetch
  CS_SEVERITY_THRESHOLD: medium

include:
  - template: Security/Container-Scanning.gitlab-ci.yml
  - template: Security/Dependency-Scanning.gitlab-ci.yml
  - template: Security/License-Scanning.gitlab-ci.yml
  - template: Security/SAST.gitlab-ci.yml
  - local: .gitlab/maintenance.yml


# Workaround to the detached pipeline as described in
# https://gitlab.com/gitlab-org/gitlab/-/issues/34756
workflow:
  rules:
    - if: '$CI_MERGE_REQUEST_EVENT_TYPE == "detached"'
      when: never
    - when: always

stages:
  # check, test, and scan the Docker images
  - initial-test
  - build-image
  - test
  # release Docker images and distro packages
  - release
  # for scheduled pipeline, we release same image everyday to keep
  # vulnerability db updated
  - maintenance

.not-on-schedule:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: '$CI_PIPELINE_SOURCE != "schedule"'
      when: on_success

.ruby-alpine:
  extends: .not-on-schedule
  image: $BUILD_IMAGES/ruby-3.0-alpine_git_build-base
  before_script:
    - bundle install --quiet

# Yamllint of CI-related yaml and changelogs.
lint-yaml:
  extends: .not-on-schedule
  image: pipelinecomponents/yamllint:latest
  stage: initial-test
  variables:
    LINT_PATHS: .gitlab-ci.yml .rubocop.yml spec/fixtures
  script:
    - yamllint -c .yamllint -f colored $LINT_PATHS

shellcheck:
  extends: .not-on-schedule
  stage: initial-test
  image: koalaman/shellcheck-alpine:stable
  script:
    - shellcheck -e SC1071 script/*

unit test:
  extends: .ruby-alpine
  stage: initial-test
  script:
    - bundle exec rake unit_test
  artifacts:
    when: always
    reports:
      junit: rspec.xml

gitlab styles:
  extends: .ruby-alpine
  stage: initial-test
  script:
    - bundle exec rubocop

dependency_scanning:
  stage: initial-test

gemnasium-dependency_scanning:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - changes:
      - Gemfile.lock

# TODO: remove this when the corresponding job in the template has been removed
bundler-audit-dependency_scanning:
  rules:
    - when: never

license_scanning:
  stage: initial-test
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - changes:
      - Gemfile.lock
      when: manual

danger-review:
  stage: initial-test
  image: registry.gitlab.com/gitlab-org/security-products/danger-bot:$DANGER_BOT_VERSION
  rules:
    - if: $CI_DEFAULT_BRANCH == $CI_COMMIT_REF_NAME
      when: never
    - if: $DANGER_DISABLED
      when: never
    - if: '$CI_COMMIT_BRANCH && $CI_PROJECT_NAMESPACE == "gitlab-org/security-products/analyzers"'
    - if: $CI_MERGE_REQUEST_IID
    - when: never
  variables:
    DANGER_BOT_VERSION: v0.11.0
    DANGER_CHANGELOG_MODE: trailer
  script:
    - cp -r /danger/ danger/
    - mv danger/analyzers/Dangerfile Dangerfile
    - |
      if [ -f danger/Gemfile ]; then
        mv danger/Gemfile Gemfile
        bundle config set path danger/vendor/
        bundle exec danger --fail-on-errors=true
      else
        danger --fail-on-errors=true
      fi

check-db-age:
  stage: test
  image: docker:20.10
  extends:
    - .scanners-matrix
  services:
    - docker:24-dind
  variables:
    IMAGE_TAG: latest
  script:
    ## For IMAGE_TAG_POSTFIX use string after `:` in DOCKERFILE_SOURCE (Dockerfile.ubi:fips => fips).
    - |
      if [ "$DOCKERFILE_SOURCE" != "Dockerfile" ]; then
        export IMAGE_TAG_POSTFIX="-${DOCKERFILE_SOURCE##*:}"
      fi
    - TARGET_IMAGE="${DEPLOY_REGISTRY_IMAGE}/${SCANNER}:${IMAGE_TAG}${IMAGE_TAG_POSTFIX}"
    - echo "Checking $TARGET_IMAGE"
    - docker run --pull=always ${TARGET_IMAGE} gtcs db-check
  rules:
    - if: '$CS_DB_CHECK_ENABLED == "true"'

.build-tmp-image:
  extends: .not-on-schedule
  # docker_ruby is not much larger than docker:stable and lives locally on our network
  image: $BUILD_IMAGES/docker-stable_ruby
  stage: build-image
  services:
    - docker:24-dind
  script:
    ## For IMAGE_TAG_POSTFIX use string after `:` in DOCKERFILE_SOURCE (Dockerfile.ubi:fips => fips).
    - |
      if [ "$DOCKERFILE_SOURCE" != "Dockerfile" ]; then
        export IMAGE_TAG_POSTFIX="-${DOCKERFILE_SOURCE##*:}"
      fi
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    # ## Use string before `:` from DOCKERFILE_SOURCE (Dockerfile.ubi:fips => Dockerfile.ubi) to build the image.
    - docker build --network host --build-arg SCANNER -f "${DOCKERFILE_SOURCE%%:*}"
      -q -t $DOCKER_IMAGE$IMAGE_TAG_POSTFIX .
    - docker push $DOCKER_IMAGE$IMAGE_TAG_POSTFIX

.scanners-matrix:
  parallel:
    matrix:
      - SCANNER: [trivy, grype]
        # DOCKERFILE_SOURCE defined with `:` is used to indicate the IMAGE_TAG_POSTFIX for the built image.
        # For backward compatibility we need to use same Dockerfile.fips twice, to build image with `-ubi`/`-fips` tags.
        # Dockerfile.fips:ubi and the logic to split it will be removed in 15.0 release.
        DOCKERFILE_SOURCE: [Dockerfile, Dockerfile.fips:fips, Dockerfile.fips:ubi]

.trivy-scanner:
  parallel:
    matrix:
      - SCANNER: [trivy]
        DOCKERFILE_SOURCE: [Dockerfile, Dockerfile.fips:fips, Dockerfile.fips:ubi]

build-scanner-image:
  extends:
    - .build-tmp-image
    - .scanners-matrix

container_scanning:
  extends:
    - .scanners-matrix
  variables:
    DOCKERFILE_PATH: $DOCKERFILE_SOURCE
    GIT_STRATEGY: fetch
  before_script:
    ## For IMAGE_TAG_POSTFIX use string after `:` in DOCKERFILE_SOURCE (Dockerfile.ubi:fips => fips).
    - |
      if [ "$DOCKERFILE_SOURCE" != "Dockerfile" ]; then
        export IMAGE_TAG_POSTFIX="-${DOCKERFILE_SOURCE##*:}"
      fi
    - export CS_IMAGE="$DOCKER_IMAGE$IMAGE_TAG_POSTFIX"
    # Using CS_IMAGE since DOCKER_IMAGE has been deprecated in v6.x which is used to scan this image
    - 'echo "Scanning: $CS_IMAGE"'
    # SCANNER causes a conflict since it is used internally
    # by GCS to determine which scanner binary to use.
    # When SCANNER=grype, it will try to use the grype
    # binary even if we want to scan using trivy.
    - export SCANNER=trivy
  rules:
    - if: $CONTAINER_SCANNING_DISABLED
      when: never
    - if: ($CI_COMMIT_BRANCH || $CI_MERGE_REQUEST_IID || $CI_COMMIT_TAG) &&
          $GITLAB_FEATURES =~ /\bcontainer_scanning\b/

.integration_test:
  extends:
    - .not-on-schedule
    - .scanners-matrix
  image: $DOCKER_IMAGE
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - vendor/ruby
  stage: test
  variables:
    IMAGE_TAG: $DOCKER_IMAGE
    CS_QUIET: "true"
  artifacts:
    when: always
    reports:
      junit: rspec.xml
  script:
    - sudo ./script/setup_integration
    - bundle config set path 'vendor/ruby'
    - bundle install --quiet
    - bundle exec rake $SPEC_NAME

.generic_integration_test:
  extends: .integration_test
  variables:
    SPEC_NAME: spec_integration_generic

alpine:
  variables:
    INTEGRATION_TEST_IMAGE: alpine:3.12.0
  extends: .generic_integration_test

centos:
  variables:
    INTEGRATION_TEST_IMAGE: centos:8
  extends: .generic_integration_test

debian:
  variables:
    INTEGRATION_TEST_IMAGE: debian:buster-20210511
  extends: .generic_integration_test

distroless:
  variables:
    INTEGRATION_TEST_IMAGE: gcr.io/distroless/base-debian9:latest
  extends: .generic_integration_test
  parallel:
    matrix:
      - SCANNER: [trivy]
        DOCKERFILE_SOURCE: [Dockerfile, Dockerfile.fips:fips, Dockerfile.fips:ubi]

ubuntu:
  variables:
    INTEGRATION_TEST_IMAGE: ubuntu:bionic-20210222
  extends: .generic_integration_test

ubi:
  variables:
    INTEGRATION_TEST_IMAGE: redhat/ubi8:8.2-299
  extends: .generic_integration_test

rhel:
  variables:
    INTEGRATION_TEST_IMAGE: registry.access.redhat.com/rhel7:7.9-333
  extends: .generic_integration_test

rockylinux:
  variables:
    INTEGRATION_TEST_IMAGE: rockylinux:8.5
  extends: .generic_integration_test

amazonlinux:
  variables:
    INTEGRATION_TEST_IMAGE: amazonlinux:2.0.20201218.1
  extends: .generic_integration_test

photon:
  variables:
    INTEGRATION_TEST_IMAGE: photon:1.0-20210409
  extends:
    - .generic_integration_test
    - .trivy-scanner

opensuseleap:
  variables:
    INTEGRATION_TEST_IMAGE: opensuse/leap:15.0
  extends:
    - .generic_integration_test
    - .trivy-scanner

oraclelinux:
  variables:
    INTEGRATION_TEST_IMAGE: oraclelinux:8.2
  extends: .generic_integration_test

almalinux:
  variables:
    INTEGRATION_TEST_IMAGE: almalinux:8.4
  extends: .generic_integration_test

webgoat:
  variables:
    INTEGRATION_TEST_IMAGE:
      "registry.gitlab.com/gitlab-org/security-products/dast/webgoat-8.0\
      @sha256:bc09fe2e0721dfaeee79364115aeedf2174cce0947b9ae5fe7c33312ee019a4e"
  extends: .generic_integration_test
  parallel:
    matrix:
      - SCANNER: [trivy]
        DOCKERFILE_SOURCE: [Dockerfile, Dockerfile.fips:fips, Dockerfile.fips:ubi]

ca cert:
  variables:
    SPEC_NAME: spec_integration_ca_cert
  extends: .integration_test

.docker_tag:
  extends:
    - .not-on-schedule
    - .scanners-matrix
  image: $BUILD_IMAGES/docker-stable_ruby
  stage: release
  services:
    - docker:24-dind
  script:
    - docker info
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    ## For IMAGE_TAG_POSTFIX use string after `:` in DOCKERFILE_SOURCE (Dockerfile.ubi:fips => fips).
    - |
      if [ "$DOCKERFILE_SOURCE" != "Dockerfile" ]; then
        export IMAGE_TAG_POSTFIX="-${DOCKERFILE_SOURCE##*:}"
      fi
    - export SOURCE_IMAGE=$DOCKER_IMAGE$IMAGE_TAG_POSTFIX
    - docker pull $SOURCE_IMAGE
    - |
      if [ "$DEFAULT_SCANNER" = "$SCANNER" ]; then
        TARGET_IMAGE=$CI_REGISTRY_IMAGE:${IMAGE_TAG:-$CI_JOB_NAME}$IMAGE_TAG_POSTFIX
        docker tag $SOURCE_IMAGE $TARGET_IMAGE
        docker push $TARGET_IMAGE
      fi
    - |
      # code below only runs if variables are defined (i.e. on protected branches/tags)
      if [ -n "$CS_DEPLOY_USERNAME" ] && [ -n "$CS_DEPLOY_PASSWORD" ] && [ -n "$IMAGE_TAG" ]; then
        docker login -u "$CS_DEPLOY_USERNAME" -p "$CS_DEPLOY_PASSWORD" "$DEPLOY_REGISTRY_IMAGE"
        if [ "$DEFAULT_SCANNER" = "$SCANNER" ]; then
          TARGET_IMAGE_DEFAULT="${DEPLOY_REGISTRY_IMAGE}:${IMAGE_TAG}${IMAGE_TAG_POSTFIX}"
          docker tag "$SOURCE_IMAGE" "$TARGET_IMAGE_DEFAULT"
          docker push "$TARGET_IMAGE_DEFAULT"
        fi
        TARGET_IMAGE_SCANNER="${DEPLOY_REGISTRY_IMAGE}/${SCANNER}:${IMAGE_TAG}${IMAGE_TAG_POSTFIX}"
        docker tag "$SOURCE_IMAGE" "$TARGET_IMAGE_SCANNER"
        docker push "$TARGET_IMAGE_SCANNER"
      else
        echo "Skipped tagging; missing one or more of: CS_DEPLOY_USERNAME, CS_DEPLOY_PASSWORD, IMAGE_TAG"
      fi

tag branch:
  extends: .docker_tag
  variables:
    # CAUTION: by preferring `SLUG` over `NAME` we can properly handle
    # non-alphanumeric characters, but this may limit our tags to 63 chars
    # or raise potential conflicts.
    IMAGE_TAG: $CI_COMMIT_REF_SLUG
  rules:
    - if: $CI_DEFAULT_BRANCH == $CI_COMMIT_REF_NAME
      when: never
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: $CI_COMMIT_BRANCH || $CI_MERGE_REQUEST_IID

tag edge:
  extends: .docker_tag
  variables:
    IMAGE_TAG: edge
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: $CI_DEFAULT_BRANCH == $CI_COMMIT_REF_NAME

.release:
  extends: .docker_tag
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: $CI_COMMIT_TAG

tag version:
  extends: .release
  before_script:
    - ./script/check_version
    - eval $(./script/export_versions)
    - export IMAGE_TAG=${CS_VERSION}

tag major:
  extends: .release
  before_script:
    - eval $(./script/export_versions)
    - export IMAGE_TAG=${CS_VERSION_MAJOR}

tag minor:
  extends: .release
  before_script:
    - eval $(./script/export_versions)
    - export IMAGE_TAG=${CS_VERSION_MINOR}

tag latest:
  extends: .release
  variables:
    IMAGE_TAG: latest
