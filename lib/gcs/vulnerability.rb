# frozen_string_literal: true

module Gcs
  class Vulnerability
    extend Forwardable

    IMAGE_NAME_AND_OS = /(?<image_name>\S*)\s\((?<operating_system>.*)\)/.freeze
    IMAGE_NAME = /(?<image_name>\S*)/.freeze

    def_delegators(:@vals, :message, :description,
                   :cve, :severity, :solution, :confidence, :scanner, :location, :identifiers)
    def initialize(params = {})
      @vals = Struct.new(*params.keys.map(&:to_sym), keyword_init: true).new(params)
      update_location_image_and_os
      update_identifier
    end

    def to_hash
      {
        'id' => id,
        'category' => 'container_scanning',
        'message' => message,
        'description' => description_or_cve,
        'cve' => cve,
        'severity' => severity,
        'confidence' => confidence,
        'solution' => solution,
        'scanner' => { 'id' => 'trivy', 'name' => 'trivy' },
        'location' => location,
        'identifiers' => identifiers,
        'links' => links
      }
    end

    def id
      # rubocop: disable GitlabSecurity/PublicSend
      hash_fields = %i[message description cve severity solution scanner location identifiers links]
      res = hash_fields.map { |getter| send(getter) }.join(':')
      Digest::SHA1.hexdigest(res)
      # rubocop: enable GitlabSecurity/PublicSend
    end

    def links
      @links ||= @vals.links.select { |x| valid_url?(x['url']) }
    end

    def operating_system
      location['operating_system']
    end

    def update_identifier
      identifiers.each { |identifier| identifier['url'] = links.first['url'] } if links.first
    end

    private

    # Some vulnerabilities doesn't have description
    def description_or_cve
      return cve if description.empty?

      description
    end

    def valid_url?(text)
      ::URI.parse(text)
      true
    rescue URI::InvalidURIError
      false
    end

    # convert Trivy image format to Gitlab
    # eg. alpine:latest (alpine 3.12.0)" -> alpine:latest
    def update_location_image_and_os
      if location['image'].match?(IMAGE_NAME_AND_OS)
        location['image'], location['operating_system'] = location['image']
                                                            .match(IMAGE_NAME_AND_OS).named_captures.values
      elsif location['image'].match?(IMAGE_NAME)
        location['image'] = location['image'].match(IMAGE_NAME).named_captures.values
      else
        Gcs.logger.error("Can't find image name")
      end
    end
  end
end
