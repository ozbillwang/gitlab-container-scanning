# frozen_string_literal: true

module Gcs
  class Vulnerability
    extend Forwardable

    IMAGE_NAME_AND_OS = /(?<image_name>\S*)\s\((?<operating_system>.*)\)/.freeze
    IMAGE_NAME = /(?<image_name>\S*)/.freeze
    # Image name with optional port and mandatory tag, without hash digest
    DEFAULT_BRANCH_IMAGE = %r{^[a-zA-Z0-9/_.-]+(:\d+[a-zA-Z0-9/_.-]*)?:[a-zA-Z0-9_.-]+$}.freeze

    SOLUTION_MAX_LENGTH = 7000
    DESCRIPTION_MAX_LENGTH = 1_048_576

    ID_FIELDS = %i[message description cve severity solution scanner location identifiers].freeze

    def_delegators(:@vals, :message, :description,
                   :cve, :severity, :solution, :scanner, :location, :identifiers)
    def initialize(params = {}, scanned_image_name = nil)
      @vals = Struct.new(*params.keys.map(&:to_sym), keyword_init: true).new(params)
      @scanned_image_name = scanned_image_name
      update_location_image_and_os
      update_identifier
    end

    def to_hash
      {
        'id' => id,
        'description' => description_or_cve.slice(0, DESCRIPTION_MAX_LENGTH),
        'severity' => severity,
        'solution' => solution.slice(0, SOLUTION_MAX_LENGTH),
        'location' => location,
        'identifiers' => identifiers,
        'links' => links
      }
    end

    def id
      # rubocop:disable Fips/SHA1
      # https://gitlab.com/gitlab-org/gitlab/-/issues/365171
      OpenSSL::Digest::SHA1.hexdigest(id_values.join(':'))
      # rubocop:enable Fips/SHA1
    end

    def links
      @links ||= @vals.links.select { |x| valid_uri?(x['url']) }
    end

    def operating_system
      location['operating_system']
    end

    def default_identifier_url(identifier)
      id = identifier['value']
      case identifier['type']
      when 'cve'
        "https://nvd.nist.gov/vuln/detail/#{id}"
      when 'ghsa'
        "https://github.com/advisories/#{id}"
      end
    end

    def update_identifier
      identifiers.each do |identifier|
        next unless identifier['url'].nil? || identifier['url'].empty?

        identifier['url'] = identifier_to_url(identifier)
      end
    end

    private

    def identifier_to_url(identifier)
      return links.first&.fetch('url') if valid_uri?(links.first&.fetch('url'))

      default_identifier_url(identifier)
    end

    def valid_uri?(maybe_uri)
      maybe_uri&.match?(/\A#{URI::DEFAULT_PARSER.make_regexp}\z/)
    end

    def id_values
      ID_FIELDS.map { |field| @vals[field] } + links
    end

    # Some vulnerabilities doesn't have description
    def description_or_cve
      return cve if description.empty?

      description
    end

    # convert Trivy image format to Gitlab
    # eg. alpine:latest (alpine 3.12.0)" -> alpine:latest
    def update_location_image_and_os
      default_branch_image = Environment.default_branch_image
      location['default_branch_image'] = default_branch_image if default_branch_image

      if default_branch_image && !default_branch_image.match?(DEFAULT_BRANCH_IMAGE)
        location.delete('default_branch_image')
        Gcs.logger.error("Ignoring invalid default_branch_image: #{default_branch_image} " \
                         "does not match #{DEFAULT_BRANCH_IMAGE.inspect}")
      end

      # set image as value provided in ENV variable or user input when image is not present in the analyzer report
      location['image'] = @scanned_image_name if location['image'].blank?

      if location['image'].match?(IMAGE_NAME_AND_OS)
        location['image'], location['operating_system'] = location['image']
                                                            .match(IMAGE_NAME_AND_OS).named_captures.values
      elsif location['image'].match?(IMAGE_NAME)
        location['image'] = location['image'].match(IMAGE_NAME).named_captures.values.first
      else
        Gcs.logger.error("Can't find image name")
      end
    end
  end
end
