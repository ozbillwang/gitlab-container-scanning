# frozen_string_literal: true

module Gcs
  class Vulnerability
    extend Forwardable

    IMAGE_NAME_AND_OS = /(?<image_name>\S*)\s\((?<operating_system>.*)\)/.freeze
    IMAGE_NAME = /(?<image_name>\S*)/.freeze

    ID_FIELDS = %i[message description cve severity solution scanner location identifiers].freeze

    def_delegators(:@vals, :message, :description,
                   :cve, :severity, :solution, :confidence, :scanner, :location, :identifiers)
    def initialize(params = {}, scanned_image_name = nil)
      @vals = Struct.new(*params.keys.map(&:to_sym), keyword_init: true).new(params)
      @scanned_image_name = scanned_image_name
      update_location_image_and_os
      update_identifier
    end

    def to_hash
      {
        'id' => id,
        'category' => 'container_scanning',
        'message' => message,
        'description' => description_or_cve,
        'cve' => cve,
        'severity' => severity,
        'confidence' => confidence,
        'solution' => solution,
        'scanner' => scanner,
        'location' => location,
        'identifiers' => identifiers,
        'links' => links
      }
    end

    def id
      Digest::SHA1.hexdigest(id_values.join(':'))
    end

    def links
      @links ||= @vals.links.select { |x| valid_url?(x['url']) }
    end

    def operating_system
      location['operating_system']
    end

    def default_identifier_url(id)
      "https://nvd.nist.gov/vuln/detail/#{id}"
    end

    def update_identifier
      identifiers.each do |identifier|
        next unless identifier['url'].nil? || identifier['url'].empty?

        identifier['url'] = links.first&.fetch('url') || default_identifier_url(identifier['name'])
      end
    end

    private

    def id_values
      ID_FIELDS.map { |field| @vals[field] } + links
    end

    # Some vulnerabilities doesn't have description
    def description_or_cve
      return cve if description.empty?

      description
    end

    def valid_url?(text)
      ::URI.parse(text)
      true
    rescue URI::InvalidURIError
      false
    end

    # convert Trivy image format to Gitlab
    # eg. alpine:latest (alpine 3.12.0)" -> alpine:latest
    def update_location_image_and_os
      default_branch_image = Environment.default_branch_image
      location['default_branch_image'] = default_branch_image if default_branch_image

      # set image as value provided in ENV variable or user input when image is not present in the analyzer report
      location['image'] = @scanned_image_name if location['image'].blank?

      if location['image'].match?(IMAGE_NAME_AND_OS)
        location['image'], location['operating_system'] = location['image']
                                                            .match(IMAGE_NAME_AND_OS).named_captures.values
      elsif location['image'].match?(IMAGE_NAME)
        location['image'] = location['image'].match(IMAGE_NAME).named_captures.values.first
      else
        Gcs.logger.error("Can't find image name")
      end
    end
  end
end
